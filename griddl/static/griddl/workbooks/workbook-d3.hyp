[{"type":"html","name":"html1","visible":true,"text":"<script src=\"https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js\"></script>"},{"type":"js","name":"js1","visible":true,"text":"// set up SVG for D3\nvar width  = 960,\n    height = 500,\n    colors = d3.scale.category10();\n\nvar svg = d3.select('#output')\n  .append('svg')\n  .attr('oncontextmenu', 'return false;')\n  .attr('width', width)\n  .attr('height', height);\n\n// set up initial nodes and links\n//  - nodes are known by 'id', not by index in array.\n//  - reflexive edges are indicated on the node (as a bold black circle).\n//  - links are always source < target; edge directions are set by 'left' and 'right'.\nvar nodes = [\n    {id: 0, reflexive: false},\n    {id: 1, reflexive: true },\n    {id: 2, reflexive: false}\n  ],\n  lastNodeId = 2,\n  links = [\n    {source: nodes[0], target: nodes[1], left: false, right: true },\n    {source: nodes[1], target: nodes[2], left: false, right: true }\n  ];\n\n// init D3 force layout\nvar force = d3.layout.force()\n    .nodes(nodes)\n    .links(links)\n    .size([width, height])\n    .linkDistance(150)\n    .charge(-500)\n    .on('tick', tick)\n\n// define arrow markers for graph links\nsvg.append('svg:defs').append('svg:marker')\n    .attr('id', 'end-arrow')\n    .attr('viewBox', '0 -5 10 10')\n    .attr('refX', 6)\n    .attr('markerWidth', 3)\n    .attr('markerHeight', 3)\n    .attr('orient', 'auto')\n  .append('svg:path')\n    .attr('d', 'M0,-5L10,0L0,5')\n    .attr('fill', '#000');\n\nsvg.append('svg:defs').append('svg:marker')\n    .attr('id', 'start-arrow')\n    .attr('viewBox', '0 -5 10 10')\n    .attr('refX', 4)\n    .attr('markerWidth', 3)\n    .attr('markerHeight', 3)\n    .attr('orient', 'auto')\n  .append('svg:path')\n    .attr('d', 'M10,-5L0,0L10,5')\n    .attr('fill', '#000');\n\n// line displayed when dragging new nodes\nvar drag_line = svg.append('svg:path')\n  .attr('class', 'link dragline hidden')\n  .attr('d', 'M0,0L0,0');\n\n// handles to link and node element groups\nvar path = svg.append('svg:g').selectAll('path'),\n    circle = svg.append('svg:g').selectAll('g');\n\n// mouse event vars\nvar selected_node = null,\n    selected_link = null,\n    mousedown_link = null,\n    mousedown_node = null,\n    mouseup_node = null;\n\nfunction resetMouseVars() {\n  mousedown_node = null;\n  mouseup_node = null;\n  mousedown_link = null;\n}\n\n// update force layout (called automatically each iteration)\nfunction tick() {\n  // draw directed edges with proper padding from node centers\n  path.attr('d', function(d) {\n    var deltaX = d.target.x - d.source.x,\n        deltaY = d.target.y - d.source.y,\n        dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n        normX = deltaX / dist,\n        normY = deltaY / dist,\n        sourcePadding = d.left ? 17 : 12,\n        targetPadding = d.right ? 17 : 12,\n        sourceX = d.source.x + (sourcePadding * normX),\n        sourceY = d.source.y + (sourcePadding * normY),\n        targetX = d.target.x - (targetPadding * normX),\n        targetY = d.target.y - (targetPadding * normY);\n    return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;\n  });\n\n  circle.attr('transform', function(d) {\n    return 'translate(' + d.x + ',' + d.y + ')';\n  });\n}\n\n// update graph (called when needed)\nfunction restart() {\n  // path (link) group\n  path = path.data(links);\n\n  // update existing links\n  path.classed('selected', function(d) { return d === selected_link; })\n    .style('marker-start', function(d) { return d.left ? 'url(#start-arrow)' : ''; })\n    .style('marker-end', function(d) { return d.right ? 'url(#end-arrow)' : ''; });\n\n\n  // add new links\n  path.enter().append('svg:path')\n    .attr('class', 'link')\n    .classed('selected', function(d) { return d === selected_link; })\n    .style('marker-start', function(d) { return d.left ? 'url(#start-arrow)' : ''; })\n    .style('marker-end', function(d) { return d.right ? 'url(#end-arrow)' : ''; })\n    .on('mousedown', function(d) {\n      if(d3.event.ctrlKey) return;\n\n      // select link\n      mousedown_link = d;\n      if(mousedown_link === selected_link) selected_link = null;\n      else selected_link = mousedown_link;\n      selected_node = null;\n      restart();\n    });\n\n  // remove old links\n  path.exit().remove();\n\n\n  // circle (node) group\n  // NB: the function arg is crucial here! nodes are known by id, not by index!\n  circle = circle.data(nodes, function(d) { return d.id; });\n\n  // update existing nodes (reflexive & selected visual states)\n  circle.selectAll('circle')\n    .style('fill', function(d) { return (d === selected_node) ? d3.rgb(colors(d.id)).brighter().toString() : colors(d.id); })\n    .classed('reflexive', function(d) { return d.reflexive; });\n\n  // add new nodes\n  var g = circle.enter().append('svg:g');\n\n  g.append('svg:circle')\n    .attr('class', 'node')\n    .attr('r', 12)\n    .style('fill', function(d) { return (d === selected_node) ? d3.rgb(colors(d.id)).brighter().toString() : colors(d.id); })\n    .style('stroke', function(d) { return d3.rgb(colors(d.id)).darker().toString(); })\n    .classed('reflexive', function(d) { return d.reflexive; })\n    .on('mouseover', function(d) {\n      if(!mousedown_node || d === mousedown_node) return;\n      // enlarge target node\n      d3.select(this).attr('transform', 'scale(1.1)');\n    })\n    .on('mouseout', function(d) {\n      if(!mousedown_node || d === mousedown_node) return;\n      // unenlarge target node\n      d3.select(this).attr('transform', '');\n    })\n    .on('mousedown', function(d) {\n      if(d3.event.ctrlKey) return;\n\n      // select node\n      mousedown_node = d;\n      if(mousedown_node === selected_node) selected_node = null;\n      else selected_node = mousedown_node;\n      selected_link = null;\n\n      // reposition drag line\n      drag_line\n        .style('marker-end', 'url(#end-arrow)')\n        .classed('hidden', false)\n        .attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + mousedown_node.x + ',' + mousedown_node.y);\n\n      restart();\n    })\n    .on('mouseup', function(d) {\n      if(!mousedown_node) return;\n\n      // needed by FF\n      drag_line\n        .classed('hidden', true)\n        .style('marker-end', '');\n\n      // check for drag-to-self\n      mouseup_node = d;\n      if(mouseup_node === mousedown_node) { resetMouseVars(); return; }\n\n      // unenlarge target node\n      d3.select(this).attr('transform', '');\n\n      // add link to graph (update if exists)\n      // NB: links are strictly source < target; arrows separately specified by booleans\n      var source, target, direction;\n      if(mousedown_node.id < mouseup_node.id) {\n        source = mousedown_node;\n        target = mouseup_node;\n        direction = 'right';\n      } else {\n        source = mouseup_node;\n        target = mousedown_node;\n        direction = 'left';\n      }\n\n      var link;\n      link = links.filter(function(l) {\n        return (l.source === source && l.target === target);\n      })[0];\n\n      if(link) {\n        link[direction] = true;\n      } else {\n        link = {source: source, target: target, left: false, right: false};\n        link[direction] = true;\n        links.push(link);\n      }\n\n      // select new link\n      selected_link = link;\n      selected_node = null;\n      restart();\n    });\n\n  // show node IDs\n  g.append('svg:text')\n      .attr('x', 0)\n      .attr('y', 4)\n      .attr('class', 'id')\n      .text(function(d) { return d.id; });\n\n  // remove old nodes\n  circle.exit().remove();\n\n  // set the graph in motion\n  force.start();\n}\n\nfunction mousedown() {\n  // prevent I-bar on drag\n  //d3.event.preventDefault();\n\n  // because :active only works in WebKit?\n  svg.classed('active', true);\n\n  if(d3.event.ctrlKey || mousedown_node || mousedown_link) return;\n\n  // insert new node at point\n  var point = d3.mouse(this),\n      node = {id: ++lastNodeId, reflexive: false};\n  node.x = point[0];\n  node.y = point[1];\n  nodes.push(node);\n\n  restart();\n}\n\nfunction mousemove() {\n  if(!mousedown_node) return;\n\n  // update drag line\n  drag_line.attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + d3.mouse(this)[0] + ',' + d3.mouse(this)[1]);\n\n  restart();\n}\n\nfunction mouseup() {\n  if(mousedown_node) {\n    // hide drag line\n    drag_line\n      .classed('hidden', true)\n      .style('marker-end', '');\n  }\n\n  // because :active only works in WebKit?\n  svg.classed('active', false);\n\n  // clear mouse event vars\n  resetMouseVars();\n}\n\nfunction spliceLinksForNode(node) {\n  var toSplice = links.filter(function(l) {\n    return (l.source === node || l.target === node);\n  });\n  toSplice.map(function(l) {\n    links.splice(links.indexOf(l), 1);\n  });\n}\n\n// only respond once per keydown\nvar lastKeyDown = -1;\n\nfunction keydown() {\n  d3.event.preventDefault();\n\n  if(lastKeyDown !== -1) return;\n  lastKeyDown = d3.event.keyCode;\n\n  // ctrl\n  if(d3.event.keyCode === 17) {\n    circle.call(force.drag);\n    svg.classed('ctrl', true);\n  }\n\n  if(!selected_node && !selected_link) return;\n  switch(d3.event.keyCode) {\n    case 8: // backspace\n    case 46: // delete\n      if(selected_node) {\n        nodes.splice(nodes.indexOf(selected_node), 1);\n        spliceLinksForNode(selected_node);\n      } else if(selected_link) {\n        links.splice(links.indexOf(selected_link), 1);\n      }\n      selected_link = null;\n      selected_node = null;\n      restart();\n      break;\n    case 66: // B\n      if(selected_link) {\n        // set link direction to both left and right\n        selected_link.left = true;\n        selected_link.right = true;\n      }\n      restart();\n      break;\n    case 76: // L\n      if(selected_link) {\n        // set link direction to left only\n        selected_link.left = true;\n        selected_link.right = false;\n      }\n      restart();\n      break;\n    case 82: // R\n      if(selected_node) {\n        // toggle node reflexivity\n        selected_node.reflexive = !selected_node.reflexive;\n      } else if(selected_link) {\n        // set link direction to right only\n        selected_link.left = false;\n        selected_link.right = true;\n      }\n      restart();\n      break;\n  }\n}\n\nfunction keyup() {\n  lastKeyDown = -1;\n\n  // ctrl\n  if(d3.event.keyCode === 17) {\n    circle\n      .on('mousedown.drag', null)\n      .on('touchstart.drag', null);\n    svg.classed('ctrl', false);\n  }\n}\n\n// app starts here\nsvg.on('mousedown', mousedown)\n  .on('mousemove', mousemove)\n  .on('mouseup', mouseup);\nd3.select(window)\n  .on('keydown', keydown)\n  .on('keyup', keyup);\nrestart();\n"}]